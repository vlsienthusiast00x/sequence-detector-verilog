# Sequence Detector (Verilog)

A small, portable Verilog implementation of a binary sequence detector. This repository demonstrates how to design, simulate, and synthesize a finite-state machine that detects a target bit sequence on a serial input stream. It is suitable for learning FSM design (Moore vs Mealy), writing testbenches, and running simulations with common open-source tools.

## Features
- Simple, well-documented Verilog implementation of a sequence detector
- Example testbench for simulation
- Instructions for running simulations using Icarus Verilog and viewing waveforms with GTKWave

## Typical project layout
- seq_detector.v        — Verilog module implementing the FSM
- tb_seq_detector.v     — Testbench for simulation
- README.md             — This file
- waveform.png          — Example waveform generated by simulation 
 
## Design overview

A sequence detector monitors a serial input stream (1-bit data) and asserts an output when the target bit pattern has been seen. Two common FSM styles:

- Moore machine
  - Output depends only on the current state.
  - Simpler to reason about, output is synchronous to the state register.
  - May require more states.
- Mealy machine
  - Output depends on current state and input.
  - Can detect the sequence earlier (in the same clock cycle as final input).
  - Can require fewer states, but output may be asynchronous relative to state transitions.

Example target sequence: 1011
- If inputs are ...1 0 1 1..., detector output pulses high when the final `1` arrives (depends on Moore/Mealy variant).

State diagram (example for sequence 1011, Mealy):
- S0 (no bits matched)
- S1 (saw 1)
- S2 (saw 10)
- S3 (saw 101)
- On receiving final 1 from S3 -> assert `detected` and transition appropriately to allow overlap detection (e.g., to S1 if last bit `1` can be the start of new sequence).
<img width="305" height="530" alt="image" src="https://github.com/user-attachments/assets/70e7c9b2-0338-41bd-bdd8-26a43c39b0b7" />


## Example module interface

A common, small module signature looks like:

```verilog
module sequence_detector #(
    parameter SEQ_WIDTH = 4,                        // width of the sequence to be matched
    parameter [SEQ_WIDTH-1:0] MATCH_SEQ = 4'b1001,  // Change this according to the required sequence to be matched
    parameter overlapping = 1                       // Toggle this for 1 for overlapping detection and 0 for non-overlapping detection
)(
    input  wire clk,
    input  wire rst,
    input  wire inp_stream,                         // Input bitstream
    output wire out_stream                          // Output bitstream
);

```

## Running simulation (Icarus Verilog + GTKWave)

Prerequisites:
- iverilog
- gtkwave

Example commands:

1. Compile and run:
   - iverilog -o tb.vvp seq_detector.v tb_seq_detector.v
   - vvp tb.vvp

2. Then open:
   - gtkwave dump.vcd

A simple testbench will toggle `inp_stream` and record `out_stream` to verify behavior for positive and overlapping or non-overlapping matches.

## Synthesis notes

- Use synchronous resets where possible for FPGA friendliness.
- For synthesis (Vivado, Quartus, etc.), put I/O constraints in the appropriate constraints file (XDC for Vivado, QSF for Quartus).
- Remove testbench files from synthesis runs.

## Verification checklist
- [ ] Unit tests (testbench vectors) for non-overlapping pattern
- [ ] Tests for overlapping pattern detection
- [ ] Reset behavior checked
- [ ] Synthesis run verifies no unexpected latches
- [ ] Timing closure for target clock frequency

## Contributing
- Feel free to open issues or PRs with:
  - Alternative FSM encodings (one-hot, binary, gray)
  - Parameterized/pattern-driven implementations
  - Additional testbenches or self-checking tests
  - Synthesis-ready project files for common FPGAs

## License
Specify a license for your repository (e.g., MIT). If you don't have one yet, add a LICENSE file. Example short notice:

This project is licensed under the MIT License — see the LICENSE file for details.

## References / Learning resources
- Digital Design — Morris Mano (FSM chapters)
- Icarus Verilog documentation: http://iverilog.icarus.com/
- GTKWave documentation: http://gtkwave.sourceforge.net/
