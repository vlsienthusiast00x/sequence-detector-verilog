# Sequence Detector (Verilog)

A small, portable Verilog implementation of a binary sequence detector. This repository demonstrates how to design, simulate, and synthesize a finite-state machine that detects a target bit sequence on a serial input stream. It is suitable for learning FSM design (Moore vs Mealy), writing testbenches, and running simulations with common open-source tools.

> Note: This README is intentionally generic so you can adapt it to any target sequence. Replace filenames, sequence, and commands with the actual files in this repo if they differ.

## Features
- Simple, well-documented Verilog implementation of a sequence detector
- Option to implement as Moore or Mealy machine (trade-offs explained below)
- Example testbench for simulation
- Instructions for running simulations using Icarus Verilog and viewing waveforms with GTKWave
- Notes for synthesis with vendor tools (Vivado/Quartus)

## Typical project layout
- sequence_detector.v        — Verilog module implementing the FSM
- tb_sequence_detector.v     — Testbench for simulation
- README.md                  — This file
- waveform.vcd               — Example waveform generated by simulation (ignored in VCS)
- constraints/                — (Optional) Synthesis constraints for FPGA

If your repo uses different filenames, update the commands below accordingly.

## Design overview

A sequence detector monitors a serial input stream (1-bit data) and asserts an output when the target bit pattern has been seen. Two common FSM styles:

- Moore machine
  - Output depends only on the current state.
  - Simpler to reason about, output is synchronous to the state register.
  - May require more states.
- Mealy machine
  - Output depends on current state and input.
  - Can detect the sequence earlier (in the same clock cycle as final input).
  - Can require fewer states, but output may be asynchronous relative to state transitions.

Example target sequence: 1011
- If inputs are ...1 0 1 1..., detector output pulses high when the final `1` arrives (depends on Moore/Mealy variant).

State diagram (example for sequence 1011, Mealy):
- S0 (no bits matched)
- S1 (saw 1)
- S2 (saw 10)
- S3 (saw 101)
- On receiving final 1 from S3 -> assert `detected` and transition appropriately to allow overlap detection (e.g., to S1 if last bit `1` can be the start of new sequence).

## Example module interface

A common, small module signature looks like:

```verilog
module sequence_detector #(
  parameter TARGET = 4 // length of sequence, or encode sequence in params
)(
  input  wire clk,
  input  wire rst_n,      // active-low synchronous reset (or use async per style)
  input  wire bit_in,     // serial input stream (one bit per clock)
  output reg  detected    // asserted when sequence is found (pulse)
);
```

Adapt port names and reset polarity for your project conventions.

## Running simulation (Icarus Verilog + GTKWave)

Prerequisites:
- iverilog
- gtkwave
- (optional) make

Example commands:

1. Compile and run:
   - iverilog -o tb.vvp sequence_detector.v tb_sequence_detector.v
   - vvp tb.vvp

2. Generate waveform (inside your testbench you can dump a VCD file, e.g., `dump.vcd`), then open:
   - gtkwave dump.vcd

A simple testbench will toggle `bit_in` and record `detected` to verify behavior for positive and overlapping matches.

Example iverilog command (replace filenames as needed):
```
iverilog -o sim.vvp sequence_detector.v tb_sequence_detector.v
vvp sim.vvp
gtkwave waveform.vcd
```

## Writing a testbench

A minimal testbench should:
- Drive `clk` and `rst_n`
- Apply a sequence of bits on `bit_in`
- Monitor `detected` and optionally print a message when detection happens
- Dump signals to a VCD file for inspection:
```verilog
initial begin
  $dumpfile("waveform.vcd");
  $dumpvars(0, tb_sequence_detector);
  // generate stimulus...
end
```

## Synthesis notes

- Use synchronous resets where possible for FPGA friendliness.
- For synthesis (Vivado, Quartus, etc.), put I/O constraints in the appropriate constraints file (XDC for Vivado, QSF for Quartus).
- Remove testbench files from synthesis runs.
- Use registers for state encoding. Consider one-hot encoding for small state machines if you need faster timing and have spare LUTs.

Vendor-specific tips:
- Xilinx Vivado: create an HDL wrapper if integrating the detector into a larger design and run synthesis/implementation flows in Vivado.
- Intel Quartus: add the Verilog file to your project, assign pins in the Pin Planner or QSF file.

## How to change the detected sequence

- If the implementation uses explicit states for a specific sequence (e.g., 1011), change the state transition logic and the final detection condition.
- For a parameterized detector (e.g., shift-register + pattern compare), change the pattern constant and the width parameter.

Parameterizable approach example (conceptual):
- Shift incoming bits into an N-bit register each clock.
- When register == PATTERN, raise `detected`.
- This is simple but can use more logic for wide patterns and care must be taken for overlapping matches (shift approach naturally supports overlap).

## Example: Overlap handling
To detect overlapping sequences (e.g., sequence `111` in stream `1111` should yield two detections), choose transitions that return to the correct matching state after a match rather than resetting to S0.

## Verification checklist
- [ ] Unit tests (testbench vectors) for non-overlapping pattern
- [ ] Tests for overlapping pattern detection
- [ ] Reset behavior checked
- [ ] Synthesis run verifies no unexpected latches
- [ ] Timing closure for target clock frequency

## Contributing
- Feel free to open issues or PRs with:
  - Alternative FSM encodings (one-hot, binary, gray)
  - Parameterized/pattern-driven implementations
  - Additional testbenches or self-checking tests
  - Synthesis-ready project files for common FPGAs

## License
Specify a license for your repository (e.g., MIT). If you don't have one yet, add a LICENSE file. Example short notice:

This project is licensed under the MIT License — see the LICENSE file for details.

## References / Learning resources
- Digital Design and Computer Architecture — Harris & Harris (FSM chapters)
- Xilinx/Intel FPGA documentation on state machines and synthesis guidelines
- Icarus Verilog documentation: http://iverilog.icarus.com/
- GTKWave documentation: http://gtkwave.sourceforge.net/

If you want, I can:
- Generate a concrete Verilog implementation (Moore or Mealy) for a specific sequence (e.g., 1011),
- Provide a ready-to-run testbench,
- Add example synthesis constraints for Vivado/Quartus,
- Or make the detector parameterizable by sequence and length.

Tell me which option you prefer and the target sequence/requirements.
